<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ADCM VIDEO</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #111; /* Dark mode background */
      color: #f4f7fa; /* Light text for better contrast */
      margin: 0;
      padding: 20px;
      text-align: center;
    }
    h1 {
      color: #f4f7fa; /* Light heading text for better contrast */
      margin-bottom: 15px;
    }
    video {
      border-radius: 10px;
      background: #000;
      max-width: 100%;
    }
    #videoContainer {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 15px;
    }
    video.main {
      border: 2px solid #007bff;
      border-radius: 10px;
      width: 60%;
      height: auto;
    }
    video.small {
      border: 2px solid #28a745;
      border-radius: 10px;
      width: 25%;
      height: auto;
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 10;
      box-shadow: 0 0 8px rgba(0,0,0,0.7);
      background: black;
    }
    .scene {
      position: relative;
      display: none;
      justify-content: center;
      align-items: center;
      gap: 10px;
      width: 100%;
      max-width: 900px;
      margin: 0 auto 20px;
      min-height: 360px;
      background: #222; /* Dark mode for scenes */
      border-radius: 12px;
      padding: 10px;
      box-sizing: border-box;
    }
    .scene.active {
      display: flex;
    }
    .scene-name {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 1.2rem;
      color: #fff;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border-radius: 5px;
    }
    #sceneButtons {
      display: none; /* Hide scene buttons initially */
      justify-content: center;
      gap: 10px;
      margin-top: 20px;
      padding: 10px;
      background: #333; /* Dark background for buttons */
      border-radius: 8px;
    }
    #sceneButtons button {
      padding: 10px 20px;
      font-size: 1rem;
      cursor: pointer;
      border: none;
      border-radius: 6px;
      background: #555;
      color: #f4f7fa;
      transition: background-color 0.3s;
    }
    #sceneButtons button.active {
      background: #007bff;
      color: white;
    }
    select, input, button {
      margin: 5px;
      padding: 10px;
      font-size: 1rem;
      border-radius: 5px;
      cursor: pointer;
      background: #333; /* Dark mode buttons */
      color: #f4f7fa; /* Light text for better contrast on dark buttons */
      border: 1px solid #555;
    }
    .toggle-btn {
      background-color: #ccc;
      color: #000;
      cursor: pointer;
      border: none;
    }
    .toggle-btn.active {
      background-color: #007bff;
      color: #fff;
    }
    .hide {
      display: none;
    }
    #editorInfo {
      font-size: 0.9rem;
      color: #f4f7fa; /* Light text for better contrast */
      margin-top: 10px;
    }
    .pre-call, .controls {
      max-width: 900px;
      margin: 0 auto 20px;
    }
    .editor-controls {
      margin-top: 15px;
    }
    .recording-icon {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background-color: red;
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      display: none;
      z-index: 1000;
    }

    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      h1 {
        font-size: 1.5rem;
      }
      video.main {
        width: 100%;
        height: auto;
      }
      video.small {
        width: 40%;
        bottom: 5px;
        right: 5px;
      }
      .scene {
        min-height: 240px;
        padding: 5px;
      }
      #sceneButtons button {
        font-size: 0.9rem;
        padding: 6px 10px;
      }
      select, input, button {
        font-size: 0.9rem;
        padding: 8px;
      }
    }
  </style>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script>
</head>
<body>
  <h1>ADCM VIDEO</h1>

  <div class="pre-call section">
    <video id="previewVideo" autoplay muted playsinline style="width: 100%; max-width: 600px; border-radius:10px; background:#000;"></video><br>

    <label for="cameraSelect">Cámara del dispositivo:</label>
    <select id="cameraSelect"></select>

    <label for="micSelect">Micrófono del dispositivo:</label>
    <select id="micSelect"></select><br>

    <button id="toggleVideo" class="toggle-btn active">Video Activado</button>
    <button id="toggleAudio" class="toggle-btn active">Micrófono Activado</button><br>

    <input type="checkbox" id="asEditor" /> <label for="asEditor">Entrar como editor (solo editor graba)</label><br>

    <button id="enterCall">Entrar a la llamada</button>
  </div>

  <div class="controls section hide">
    <!-- Elimina escenas individuales, solo deja escenas grupales (ambos usuarios) -->
    <!-- Escena 1: Ambos lado a lado -->
    <div id="scene1" class="scene">
      <!-- <div class="scene-name">Ambos lado a lado</div> -->
      <video id="localVideo1" class="main" autoplay muted playsinline></video>
      <video id="remoteVideo1" class="main" autoplay playsinline></video>
      <!-- <div class="scene-controls">
        <button class="scene-btn" data-scene="scene2">Ir a PiP Local grande</button>
      </div> -->
    </div>
    <!-- Escena 2: Local grande, remoto pequeño -->
    <div id="scene2" class="scene">
      <!-- <div class="scene-name">Local grande, remoto pequeño</div> -->
      <video id="localVideo2" class="main" autoplay muted playsinline></video>
      <video id="remoteVideo2" class="small" autoplay playsinline></video>
      <!-- <div class="scene-controls">
        <button class="scene-btn" data-scene="scene3">Ir a PiP Remoto grande</button>
      </div> -->
    </div>
    <!-- Escena 3: Remoto grande, local pequeño -->
    <div id="scene3" class="scene">
      <!-- <div class="scene-name">Remoto grande, local pequeño</div> -->
      <video id="remoteVideo3" class="main" autoplay playsinline></video>
      <video id="localVideo3" class="small" autoplay muted playsinline></video>
      <div class="scene-controls">
        <button class="scene-btn" data-scene="scene4">Ir a Ambos vertical</button>
      </div>
    </div>
    <!-- Escena 4: Ambos vertical (uno arriba del otro) -->
    <div id="scene4" class="scene">
      <!-- <div class="scene-name">Ambos vertical</div> -->
      <div style="display:flex;flex-direction:row;width:100%;align-items:center;justify-content:center;">
        <video id="localVideo4" class="main" style="width:45%;height:auto;" autoplay muted playsinline></video>
        <video id="remoteVideo4" class="main" style="width:45%;height:auto;" autoplay playsinline></video>
      </div>
      <div class="scene-controls">
        <button class="scene-btn" data-scene="scene5">Ir a Local grande, remoto pequeño (esquina)</button>
      </div>
    </div>
    <!-- Escena 5: Local grande, remoto pequeño esquina -->
    <div id="scene5" class="scene">
      <!-- <div class="scene-name">Local grande, remoto pequeño (esquina)</div> -->
      <video id="localVideo5" class="main" autoplay muted playsinline></video>
      <video id="remoteVideo5" class="small" style="bottom:30px;right:30px;" autoplay playsinline></video>
      <div class="scene-controls">
        <button class="scene-btn" data-scene="scene6">Ir a Remoto grande, local pequeño (esquina)</button>
      </div>
    </div>
    <!-- Escena 6: Remoto grande, local pequeño esquina -->
    <div id="scene6" class="scene">
      <!-- <div class="scene-name">Remoto grande, local pequeño (esquina)</div> -->
      <video id="remoteVideo6" class="main" autoplay playsinline></video>
      <video id="localVideo6" class="small" style="bottom:30px;right:30px;" autoplay muted playsinline></video>
      <div class="scene-controls">
        <button class="scene-btn" data-scene="scene1">Ir a Ambos lado a lado</button>
      </div>
    </div>

    <div style="margin-top: 15px;">
      <div id="creatorFields">
        <input id="callTitle" placeholder="Título de la llamada" style="width: 200px;"/><br>
        <button id="startCall">Crear llamada</button>
        <span id="callCode" style="display:none;color:#fff;font-size:1.1rem;"></span>
      </div>
      <div id="joinerFields">
        <button id="joinCall">Unirse a llamada</button>
        <input id="callId" placeholder="ID de llamada" style="width: 200px;"/><br>
      </div>
      <span id="callStatus" style="color:#0f0;font-weight:bold;"></span><br>
      <!-- Botones de grabación solo para el editor -->
      <button id="startRecording" style="display:none;">Iniciar grabación</button>
      <button id="stopRecording" style="display:none;" disabled>Detener grabación</button>
    </div>
    <div id="joinedTitle" style="margin-top:10px;color:#fff;font-size:1.1rem;display:none;"></div>
    <p id="editorInfo" class="hide">Estás en modo editor. Solo tú puedes grabar.</p>
    <div class="editor-controls"></div>

    <!-- Botones para cambiar de escena -->
    <div id="sceneFooterButtons" style="margin-top:30px; display:flex; justify-content:center; gap:10px;">
      <button class="scene-footer-btn" data-scene="scene1">Ambos lado a lado</button>
      <button class="scene-footer-btn" data-scene="scene2">Local grande</button>
      <button class="scene-footer-btn" data-scene="scene3">Remoto grande</button>
      <button class="scene-footer-btn" data-scene="scene4">Ambos vertical</button>
      <button class="scene-footer-btn" data-scene="scene5">Local grande esquina</button>
      <button class="scene-footer-btn" data-scene="scene6">Remoto grande esquina</button>
    </div>
  </div>

  <div id="recordingIcon" class="recording-icon"></div>

  <script>
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyC6shbQniv5FeXnJYaSasbGKdYibDWhxV8",
      authDomain: "fir-rtc-1d4a1.firebaseapp.com",
      databaseURL: "https://fir-rtc-1d4a1-default-rtdb.firebaseio.com",
      projectId: "fir-rtc-1d4a1",
      storageBucket: "fir-rtc-1d4a1.appspot.com",
      messagingSenderId: "786317659414",
      appId: "1:786317659414:web:4b9fe6fecc349647d1d437"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const storage = firebase.storage();

    const servers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    // Global variables
    let localStream1, localStream2, peerConnection;
    // --- Variables para modo editor y grabación ---
    let isEditor = false;
    let mediaRecorder;
    let recordedChunks = [];

    // DOM elements
    const previewVideo = document.getElementById('previewVideo');
    const cameraSelect = document.getElementById('cameraSelect');
    const micSelect = document.getElementById('micSelect');
    const toggleVideoBtn = document.getElementById('toggleVideo');
    const toggleAudioBtn = document.getElementById('toggleAudio');
    const enterCallBtn = document.getElementById('enterCall');
    const callIdInput = document.getElementById('callId');
    const startCallBtn = document.getElementById('startCall');
    const joinCallBtn = document.getElementById('joinCall');
    const startRecordingBtn = document.getElementById('startRecording');
    const stopRecordingBtn = document.getElementById('stopRecording');
    const asEditorCheckbox = document.getElementById('asEditor');
    const editorInfo = document.getElementById('editorInfo');
    const recordingIcon = document.getElementById('recordingIcon');
    const sceneButtons = [...document.querySelectorAll('#sceneButtons button')];
    const scenes = [
      document.getElementById('scene1'),
      document.getElementById('scene2'),
      document.getElementById('scene3'),
      document.getElementById('scene4'),
      document.getElementById('scene5'),
      document.getElementById('scene6')
    ].filter(Boolean);

    const camsLocal = {
      1: document.getElementById('localVideo1'),
      2: document.getElementById('localVideo2'),
      3: document.getElementById('localVideo3'),
      4: document.getElementById('localVideo4'),
      5: document.getElementById('localVideo5'),
      6: document.getElementById('localVideo6'),
    };

    const camsRemote = {
      1: document.getElementById('remoteVideo1'),
      2: document.getElementById('remoteVideo2'),
      3: document.getElementById('remoteVideo3'),
      4: document.getElementById('remoteVideo4'),
      5: document.getElementById('remoteVideo5'),
      6: document.getElementById('remoteVideo6'),
    };

    // Utility functions
    async function getDevices() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(d => d.kind === 'videoinput');
        const audioDevices = devices.filter(d => d.kind === 'audioinput');

        // Para móviles, mostrar etiquetas genéricas si no hay label
        cameraSelect.innerHTML = videoDevices.map((device, index) => {
          let label = device.label || (device.deviceId && device.deviceId.includes('front') ? 'Frontal' : device.deviceId && device.deviceId.includes('back') ? 'Trasera' : `Cámara ${index + 1}`);
          // Si no hay label y hay dos cámaras, la primera es frontal, la segunda trasera
          if (!device.label && videoDevices.length === 2) {
            label = index === 0 ? 'Frontal' : 'Trasera';
          }
          return `<option value="${device.deviceId}">${label}</option>`;
        }).join('');

        micSelect.innerHTML = audioDevices.map((device, index) =>
          `<option value="${device.deviceId}">${device.label || `Micrófono ${index + 1}`}</option>`
        ).join('');

        if (!videoDevices.length || !audioDevices.length) {
          alert('Por favor, habilita permisos de cámara y micrófono en tu dispositivo.');
        }
      } catch (error) {
        alert('No se pudieron obtener los dispositivos. Verifica los permisos.');
      }
    }

    async function getStreams() {
      try {
        const videoDeviceId = cameraSelect.value;
        const audioDeviceId = micSelect.value;

        localStream1 = await navigator.mediaDevices.getUserMedia({
          video: videoDeviceId ? { deviceId: { exact: videoDeviceId } } : true,
          audio: audioDeviceId ? { deviceId: { exact: audioDeviceId } } : true,
        });

        // Get second camera if available
        const videoDevices = (await navigator.mediaDevices.enumerateDevices()).filter(d => d.kind === 'videoinput');
        const secondCamId = videoDevices.find(d => d.deviceId !== videoDeviceId)?.deviceId;
        localStream2 = secondCamId
          ? await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: secondCamId } }, audio: false })
          : localStream1.clone();

        previewVideo.srcObject = localStream1;
        previewVideo.play().catch(() => {});
      } catch (error) {
        alert('No se pudo acceder a la cámara o micrófono. Permisos denegados o no disponibles.');
      }
    }

    function assignLocalStreams() {
      Object.entries(camsLocal).forEach(([key, cam]) => {
        cam.srcObject = key === '1' ? localStream2 : localStream1;
        cam.play().catch(() => {});
      });
    }

    // Cambia la escena y resalta el botón activo
    function switchScene(sceneId) {
      scenes.forEach(scene => {
        scene.style.display = 'none';
        scene.classList.remove('active');
      });
      const targetScene = document.getElementById(sceneId);
      if (targetScene) {
        targetScene.style.display = 'flex';
        targetScene.classList.add('active');
      }
      document.querySelectorAll('.scene-footer-btn').forEach(btn => {
        btn.classList.toggle('active', btn.getAttribute('data-scene') === sceneId);
      });
      assignSceneStreams(sceneId);
    }

    // Helper to show/hide creator/joiner fields
    function showCreatorUI(callId, title) {
      document.getElementById('creatorFields').style.display = '';
      document.getElementById('joinerFields').style.display = 'none';
      document.getElementById('callTitle').style.display = '';
      document.getElementById('callTitle').value = title || '';
      document.getElementById('startCall').style.display = 'none';
      // Mostrar el código de la llamada en texto
      const callCode = document.getElementById('callCode');
      callCode.style.display = '';
      callCode.textContent = "Código de la llamada: " + callId;
      document.getElementById('joinedTitle').style.display = 'none';
      updateRecordingButtons();
      document.getElementById('sceneFooterButtons').style.display = 'flex';
      setDefaultScene();
      assignSceneStreams('scene1');
    }
    function showJoinerUI(title) {
      document.getElementById('creatorFields').style.display = 'none';
      document.getElementById('joinerFields').style.display = 'none';
      document.getElementById('callTitle').style.display = 'none';
      // document.getElementById('callCode').style.display = 'none';
      document.getElementById('joinedTitle').style.display = '';
      document.getElementById('joinedTitle').textContent = "Título de la llamada: " + (title || '');
      updateRecordingButtons();
      document.getElementById('sceneFooterButtons').style.display = 'flex';
      setDefaultScene();
      assignSceneStreams('scene1');
    }

    // --- Scene assignment: always show both videos in all scenes ---
    // Guardar el último stream remoto recibido
    let lastRemoteStream = null;

    // Asignar el stream remoto a los elementos de video remotos y refrescar la escena activa
    function assignRemoteStream(stream) {
      lastRemoteStream = stream;
      Object.values(camsRemote).forEach(cam => {
        if (cam) cam.srcObject = stream;
      });
      const activeScene = document.querySelector('.scene.active');
      if (activeScene) assignSceneStreams(activeScene.id);
    }

    // Modificar assignSceneStreams para que ambos videos sean el remoto (lastRemoteStream)
    function assignSceneStreams(sceneId) {
      // Ambos videos muestran el stream remoto
      const remoteStream = lastRemoteStream || (peerConnection && peerConnection.getReceivers && peerConnection.getReceivers().find(r => r.track && r.track.kind === 'video')?.track && new MediaStream([peerConnection.getReceivers().find(r => r.track && r.track.kind === 'video').track])) || localStream2;
      Object.entries(camsLocal).forEach(([k, v]) => v && (v.style.display = 'none'));
      Object.entries(camsRemote).forEach(([k, v]) => v && (v.style.display = 'none'));
      if (sceneId === 'scene1') {
        camsLocal[1].srcObject = remoteStream;
        camsRemote[1].srcObject = remoteStream;
        camsLocal[1].style.display = '';
        camsRemote[1].style.display = '';
      } else if (sceneId === 'scene2') {
        camsLocal[2].srcObject = remoteStream;
        camsRemote[2].srcObject = remoteStream;
        camsLocal[2].style.display = '';
        camsRemote[2].style.display = '';
      } else if (sceneId === 'scene3') {
        camsRemote[3].srcObject = remoteStream;
        camsLocal[3].srcObject = remoteStream;
        camsRemote[3].style.display = '';
        camsLocal[3].style.display = '';
      } else if (sceneId === 'scene4') {
        camsLocal[4].srcObject = remoteStream;
        camsRemote[4].srcObject = remoteStream;
        camsLocal[4].style.display = '';
        camsRemote[4].style.display = '';
      } else if (sceneId === 'scene5') {
        camsLocal[5].srcObject = remoteStream;
        camsRemote[5].srcObject = remoteStream;
        camsLocal[5].style.display = '';
        camsRemote[5].style.display = '';
      } else if (sceneId === 'scene6') {
        camsRemote[6].srcObject = remoteStream;
        camsLocal[6].srcObject = remoteStream;
        camsRemote[6].style.display = '';
        camsLocal[6].style.display = '';
      }
    }

    // Botones de cambio de escena
    function setupSceneButtons() {
      document.querySelectorAll('.scene-btn').forEach(btn => {
        btn.onclick = function() {
          if (!isEditor) return;
          switchScene(this.getAttribute('data-scene'));
        };
      });
    }
    function setupSceneFooterButtons() {
      document.querySelectorAll('.scene-footer-btn').forEach(btn => {
        btn.onclick = function() {
          if (!isEditor) return;
          switchScene(this.getAttribute('data-scene'));
        };
      });
    }

    // Cambia la escena y resalta el botón activo
    function switchScene(sceneId) {
      scenes.forEach(scene => {
        scene.style.display = 'none';
        scene.classList.remove('active');
      });
      const targetScene = document.getElementById(sceneId);
      if (targetScene) {
        targetScene.style.display = 'flex';
        targetScene.classList.add('active');
      }
      document.querySelectorAll('.scene-footer-btn').forEach(btn => {
        btn.classList.toggle('active', btn.getAttribute('data-scene') === sceneId);
      });
      assignSceneStreams(sceneId);
    }

    // Initialization
    document.addEventListener('DOMContentLoaded', async () => {
      await getDevices();
      await getStreams();
      assignLocalStreams();
      setupSceneButtons();
      setupSceneFooterButtons();
      setDefaultScene();
      updateEditorInfo();
      assignSceneStreams('scene1');
    });

    enterCallBtn.addEventListener('click', async () => {
      isEditor = asEditorCheckbox.checked;
      if (!localStream1) {
        alert('Por favor selecciona cámara y micrófono y acepta permisos.');
        return;
      }
      document.querySelector('.pre-call').classList.add('hide');
      document.querySelector('.controls').classList.remove('hide');
      assignLocalStreams();
      setDefaultScene();
      setupSceneButtons();
      setupSceneFooterButtons();
      updateEditorInfo();
      // Forzar mostrar el video local en la escena predeterminada
      assignSceneStreams('scene1');
    });

    // Utilidad para generar un ID corto (6 caracteres alfanuméricos)
    function generateShortId() {
      return Math.random().toString(36).substr(2, 6).toUpperCase();
    }

    // Mostrar estado de conexión
    function setCallStatus(msg, color = "#0f0") {
      const el = document.getElementById('callStatus');
      el.textContent = msg;
      el.style.color = color;
      if (msg === "Conectado") {
        hideCallInputsAfterConnect();
      }
    }

    // Call creation/join logic
    let callRef = null;
    let callerCandidatesCollection = null;
    let calleeCandidatesCollection = null;

    document.getElementById('startCall').addEventListener('click', async () => {
      isCreator = true;
      // Genera un ID corto y lo usa como clave
      const shortId = generateShortId();
      callRef = db.ref('calls/' + shortId);
      callIdInput.value = shortId;
      const title = document.getElementById('callTitle').value.trim();
      if (title) await callRef.child('title').set(title);

      // Hide join fields, show code and title
      showCreatorUI(shortId, title);

      peerConnection = new RTCPeerConnection(servers);
      localStream1.getTracks().forEach(track => peerConnection.addTrack(track, localStream1));
      localStream2.getTracks().forEach(track => peerConnection.addTrack(track, localStream2));

      callerCandidatesCollection = callRef.child('callerCandidates');
      peerConnection.onicecandidate = event => {
        if (event.candidate) {
          callerCandidatesCollection.push(event.candidate.toJSON());
        }
      };

      peerConnection.ontrack = event => {
        assignRemoteStream(event.streams[0]);
      };

      peerConnection.onconnectionstatechange = () => {
        if (peerConnection.connectionState === "connected") setCallStatus("Conectado", "#0f0");
      };

      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      await callRef.child('offer').set({ type: offer.type, sdp: offer.sdp });

      callRef.child('answer').on('value', async snapshot => {
        const answer = snapshot.val();
        if (answer && !peerConnection.currentRemoteDescription) {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        }
      });

      callRef.child('calleeCandidates').on('child_added', snapshot => {
        const candidate = new RTCIceCandidate(snapshot.val());
        peerConnection.addIceCandidate(candidate);
      });

      setCallStatus("Esperando conexión...", "#ff0");
    });

    document.getElementById('joinCall').addEventListener('click', async () => {
      isCreator = false;
      const callId = callIdInput.value.trim();
      if (!callId) {
        alert('Por favor ingresa un ID de llamada para unirse.');
        return;
      }

      callRef = db.ref('calls/' + callId);

      // Get title and show only title for joiner
      const titleSnap = await callRef.child('title').once('value');
      const title = titleSnap.val();
      showJoinerUI(title);

      // Verifica si existe la llamada
      const offerSnapshot = await callRef.child('offer').once('value');
      const offer = offerSnapshot.val();
      if (!offer) {
        alert('No se encontró una oferta para esta llamada. Verifica el ID de llamada.');
        setCallStatus("ID no válido", "#f00");
        // No ocultar/join UI ni avanzar, simplemente salir
        return;
      }

      peerConnection = new RTCPeerConnection(servers);
      localStream1.getTracks().forEach(track => peerConnection.addTrack(track, localStream1));
      localStream2.getTracks().forEach(track => peerConnection.addTrack(track, localStream2));

      calleeCandidatesCollection = callRef.child('calleeCandidates');
      const offerCandidatesCollection = callRef.child('callerCandidates');

      peerConnection.onicecandidate = event => {
        if (event.candidate) {
          calleeCandidatesCollection.push(event.candidate.toJSON());
        }
      };

      peerConnection.ontrack = event => {
        assignRemoteStream(event.streams[0]);
      };

      peerConnection.onconnectionstatechange = () => {
        if (peerConnection.connectionState === "connected") setCallStatus("Conectado", "#0f0");
      };

      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      await callRef.child('answer').set({ type: answer.type, sdp: answer.sdp });

      offerCandidatesCollection.on('child_added', snapshot => {
        const candidate = new RTCIceCandidate(snapshot.val());
        peerConnection.addIceCandidate(candidate).catch(e => console.error('Error adding ICE candidate:', e));
      });

      setCallStatus("Conectando...", "#ff0");
    });

    // Previsualización de escenas: muestra cómo se vería cada escena (composición grupal)
    function updateScenePreviews() {
      // Usuario 1: localStream1, Usuario 2: remoteStream (peerConnection) o localStream2
      const remoteStream = peerConnection?.getRemoteStreams?.()[0] || localStream2;

      // Escena 1: Solo usuario 1 (solo local)
      setPreviewScene('previewScene1', [localStream1], 'single');
      // Escena 2: Solo usuario 2 (solo remoto)
      setPreviewScene('previewScene2', [remoteStream], 'single');
      // Escena 3: usuario 1 y 2 vertical alado horizontalmente (ambos)
      setPreviewScene('previewScene3', [localStream1, remoteStream], 'side');
      // Escena 4: usuario 1 y 2 horizontal uno alado del otro (ambos)
      setPreviewScene('previewScene4', [localStream1, remoteStream], 'side');
      // Escena 5: usuario 1 grande, usuario 2 pequeño a un lado (ambos)
      setPreviewScene('previewScene5', [localStream1, remoteStream], 'pip1');
      // Escena 6: usuario 2 grande, usuario 1 pequeño a un lado (ambos)
      setPreviewScene('previewScene6', [remoteStream, localStream1], 'pip2');
    }

    // Helper para mostrar la composición de la escena en un canvas y ponerlo en el video de preview
    function setPreviewScene(previewId, streams, layout = 'single') {
      const preview = document.getElementById(previewId);
      if (!preview) return;

      // Detener cualquier stream anterior
      if (preview.srcObject) {
        preview.srcObject.getTracks().forEach(track => track.stop && track.stop());
        preview.srcObject = null;
      }

      // Si solo hay un stream, mostrarlo directo
      if (streams.length === 1 || layout === 'single') {
        preview.srcObject = streams[0] || null;
        preview.play().catch(() => {});
        return;
      }

      // Si hay dos streams, hacer composición en canvas (grupal)
      const canvas = document.createElement('canvas');
      canvas.width = 120;
      canvas.height = 80;
      const ctx = canvas.getContext('2d');
      const v1 = document.createElement('video');
      const v2 = document.createElement('video');
      v1.muted = true; v2.muted = true;
      v1.autoplay = true; v2.autoplay = true;
      v1.playsInline = true; v2.playsInline = true;
      v1.srcObject = streams[0] || null;
      v2.srcObject = streams[1] || null;

      // Esperar a que ambos videos estén listos
      Promise.all([
        new Promise(res => v1.onloadeddata = res),
        new Promise(res => v2.onloadeddata = res)
      ]).then(() => {
        function draw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          if (layout === 'side') {
            // Dos videos lado a lado (grupal)
            ctx.drawImage(v1, 0, 0, canvas.width / 2, canvas.height);
            ctx.drawImage(v2, canvas.width / 2, 0, canvas.width / 2, canvas.height);
          } else if (layout === 'pip1') {
            // Usuario 1 grande, usuario 2 pequeño esquina (grupal)
            ctx.drawImage(v1, 0, 0, canvas.width, canvas.height);
            ctx.drawImage(v2, canvas.width - 40, canvas.height - 30, 40, 30);
          } else if (layout === 'pip2') {
            // Usuario 2 grande, usuario 1 pequeño esquina (grupal)
            ctx.drawImage(v1, 0, 0, canvas.width, canvas.height);
            ctx.drawImage(v2, canvas.width - 40, canvas.height - 30, 40, 30);
          }
          requestAnimationFrame(draw);
        }
        draw();
      });

      // Asigna el stream del canvas al video de preview
      const stream = canvas.captureStream();
      preview.srcObject = stream;
      preview.play().catch(() => {});
    }

    // Llama a updateScenePreviews cuando cambian los streams o al iniciar
    document.addEventListener('DOMContentLoaded', () => {
      updateScenePreviews();
    });
    cameraSelect.addEventListener('change', async () => {
      await getStreams();
      assignLocalStreams();
      updateScenePreviews();
    });
    micSelect.addEventListener('change', async () => {
      await getStreams();
      assignLocalStreams();
      updateScenePreviews();
    });
    enterCallBtn.addEventListener('click', () => {
      updateScenePreviews();
    });

    // También actualiza las previsualizaciones cuando se asignan los streams
    function assignLocalStreams() {
      Object.entries(camsLocal).forEach(([key, cam]) => {
        cam.srcObject = key === '1' ? localStream2 : localStream1;
        cam.play().catch(e => console.error(`Error playing local video ${key}:`, e));
      });
      updateScenePreviews();
    }

    // --- Grabación solo para el editor ---
    startRecordingBtn.onclick = async function() {
      if (!isEditor) return;
      // Graba la escena activa (ambos videos en la escena)
      const activeScene = document.querySelector('.scene.active');
      const videos = activeScene.querySelectorAll('video');
      // Crea un canvas para mezclar ambos videos
      const canvas = document.createElement('canvas');
      canvas.width = 1280;
      canvas.height = 720;
      const ctx = canvas.getContext('2d');
      let v1 = videos[0], v2 = videos[1];
      v1.muted = true; v2.muted = true;
      v1.play(); v2.play();
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (activeScene.id === 'scene1') {
          ctx.drawImage(v1, 0, 0, canvas.width / 2, canvas.height);
          ctx.drawImage(v2, canvas.width / 2, 0, canvas.width / 2, canvas.height);
        } else if (activeScene.id === 'scene2') {
          ctx.drawImage(v1, 0, 0, canvas.width, canvas.height);
          ctx.drawImage(v2, canvas.width - 320, canvas.height - 180, 320, 180);
        } else if (activeScene.id === 'scene3') {
          ctx.drawImage(v1, 0, 0, canvas.width, canvas.height);
          ctx.drawImage(v2, canvas.width - 320, canvas.height - 180, 320, 180);
        } else if (activeScene.id === 'scene4') {
          ctx.drawImage(v1, 0, 0, canvas.width / 2, canvas.height);
          ctx.drawImage(v2, canvas.width / 2, 0, canvas.width / 2, canvas.height);
        } else if (activeScene.id === 'scene5') {
          ctx.drawImage(v1, 0, 0, canvas.width, canvas.height);
          ctx.drawImage(v2, canvas.width - 320, canvas.height - 180, 320, 180);
        } else if (activeScene.id === 'scene6') {
          ctx.drawImage(v1, 0, 0, canvas.width, canvas.height);
          ctx.drawImage(v2, canvas.width - 320, canvas.height - 180, 320, 180);
        }
        requestAnimationFrame(draw);
      }
      draw();
      // Mezcla audio de ambos streams
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const dest = audioCtx.createMediaStreamDestination();
      [v1, v2].forEach(video => {
        try {
          const src = audioCtx.createMediaStreamSource(video.srcObject);
          src.connect(dest);
        } catch {}
      });
      const stream = canvas.captureStream(30);
      dest.stream.getAudioTracks().forEach(track => stream.addTrack(track));
      mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9,opus' });
      recordedChunks = [];
      mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'grabacion.webm';
        a.click();
        URL.revokeObjectURL(url);
      };
      mediaRecorder.start();
      startRecordingBtn.disabled = true;
      stopRecordingBtn.disabled = false;
      recordingIcon.style.display = '';
    };

    stopRecordingBtn.onclick = function() {
      if (!isEditor || !mediaRecorder) return;
      mediaRecorder.stop();
      startRecordingBtn.disabled = false;
      stopRecordingBtn.disabled = true;
      recordingIcon.style.display = 'none';
    };

    // --- Solo el editor puede cambiar escenas y grabar ---
    function updateEditorInfo() {
      updateRecordingButtons();
      // Deshabilita/enhabilita botones de escena para no editores
      document.querySelectorAll('.scene-btn, .scene-footer-btn').forEach(btn => {
        btn.disabled = !isEditor;
        btn.style.opacity = isEditor ? '1' : '0.5';
        btn.style.pointerEvents = isEditor ? '' : 'none';
      });
    }

    // --- Al entrar a la llamada, determina si es editor ---
    enterCallBtn.addEventListener('click', async () => {
      isEditor = asEditorCheckbox.checked;
      if (!localStream1) {
        alert('Por favor selecciona cámara y micrófono y acepta permisos.');
        return;
      }
      document.querySelector('.pre-call').classList.add('hide');
      document.querySelector('.controls').classList.remove('hide');
      assignLocalStreams();
      setDefaultScene();
      setupSceneButtons();
      setupSceneFooterButtons();
      updateEditorInfo();
      // Forzar mostrar el video local en la escena predeterminada
      assignSceneStreams('scene1');
    });

    // --- Al crear o unirse a llamada, actualiza controles de editor ---
    document.getElementById('startCall').addEventListener('click', async () => {
      isCreator = true;
      // Genera un ID corto y lo usa como clave
      const shortId = generateShortId();
      callRef = db.ref('calls/' + shortId);
      callIdInput.value = shortId;
      const title = document.getElementById('callTitle').value.trim();
      if (title) await callRef.child('title').set(title);

      // Hide join fields, show code and title
      showCreatorUI(shortId, title);

      peerConnection = new RTCPeerConnection(servers);
      localStream1.getTracks().forEach(track => peerConnection.addTrack(track, localStream1));
      localStream2.getTracks().forEach(track => peerConnection.addTrack(track, localStream2));

      callerCandidatesCollection = callRef.child('callerCandidates');
      peerConnection.onicecandidate = event => {
        if (event.candidate) {
          callerCandidatesCollection.push(event.candidate.toJSON());
        }
      };

      peerConnection.ontrack = event => {
        assignRemoteStream(event.streams[0]);
      };

      peerConnection.onconnectionstatechange = () => {
        if (peerConnection.connectionState === "connected") setCallStatus("Conectado", "#0f0");
      };

      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      await callRef.child('offer').set({ type: offer.type, sdp: offer.sdp });

      callRef.child('answer').on('value', async snapshot => {
        const answer = snapshot.val();
        if (answer && !peerConnection.currentRemoteDescription) {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        }
      });

      callRef.child('calleeCandidates').on('child_added', snapshot => {
        const candidate = new RTCIceCandidate(snapshot.val());
        peerConnection.addIceCandidate(candidate);
      });

      setCallStatus("Esperando conexión...", "#ff0");
    });

    document.getElementById('joinCall').addEventListener('click', async () => {
      isCreator = false;
      const callId = callIdInput.value.trim();
      if (!callId) {
        alert('Por favor ingresa un ID de llamada para unirse.');
        return;
      }

      callRef = db.ref('calls/' + callId);

      // Get title and show only title for joiner
      const titleSnap = await callRef.child('title').once('value');
      const title = titleSnap.val();
      showJoinerUI(title);

      // Verifica si existe la llamada
      const offerSnapshot = await callRef.child('offer').once('value');
      const offer = offerSnapshot.val();
      if (!offer) {
        alert('No se encontró una oferta para esta llamada. Verifica el ID de llamada.');
        setCallStatus("ID no válido", "#f00");
        // No ocultar/join UI ni avanzar, simplemente salir
        return;
      }

      peerConnection = new RTCPeerConnection(servers);
      localStream1.getTracks().forEach(track => peerConnection.addTrack(track, localStream1));
      localStream2.getTracks().forEach(track => peerConnection.addTrack(track, localStream2));

      calleeCandidatesCollection = callRef.child('calleeCandidates');
      const offerCandidatesCollection = callRef.child('callerCandidates');

      peerConnection.onicecandidate = event => {
        if (event.candidate) {
          calleeCandidatesCollection.push(event.candidate.toJSON());
        }
      };

      peerConnection.ontrack = event => {
        assignRemoteStream(event.streams[0]);
      };

      peerConnection.onconnectionstatechange = () => {
        if (peerConnection.connectionState === "connected") setCallStatus("Conectado", "#0f0");
      };

      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      await callRef.child('answer').set({ type: answer.type, sdp: answer.sdp });

      offerCandidatesCollection.on('child_added', snapshot => {
        const candidate = new RTCIceCandidate(snapshot.val());
        peerConnection.addIceCandidate(candidate).catch(e => console.error('Error adding ICE candidate:', e));
      });

      setCallStatus("Conectando...", "#ff0");
    });

    // --- Fix: toggle video/audio and camera switching for mobile ---

    // Helper to get new stream with current device selections and track states
    async function refreshStreamsAndTracks() {
      try {
        const videoDeviceId = cameraSelect.value;
        const audioDeviceId = micSelect.value;
        // Always request both video and audio, but set enabled state after
        const newStream = await navigator.mediaDevices.getUserMedia({
          video: videoDeviceId ? { deviceId: { exact: videoDeviceId } } : true,
          audio: audioDeviceId ? { deviceId: { exact: audioDeviceId } } : true,
        });
        // Replace tracks in localStream1
        if (localStream1) {
          // Stop old tracks
          localStream1.getTracks().forEach(track => track.stop());
        }
        localStream1 = newStream;
        // Set enabled state for tracks
        localStream1.getVideoTracks().forEach(track => track.enabled = videoEnabled);
        localStream1.getAudioTracks().forEach(track => track.enabled = audioEnabled);
        previewVideo.srcObject = localStream1;
        previewVideo.play().catch(() => {});
        assignLocalStreams();
      } catch (e) {
        alert('No se pudo acceder a la cámara o micrófono. Permisos denegados o no disponibles.');
      }
    }

    // Track state
    let videoEnabled = true;
    let audioEnabled = true;

    // Toggle video
    toggleVideoBtn.addEventListener('click', async () => {
      videoEnabled = !videoEnabled;
      if (localStream1) {
        localStream1.getVideoTracks().forEach(track => track.enabled = videoEnabled);
      }
      toggleVideoBtn.classList.toggle('active', videoEnabled);
      toggleVideoBtn.textContent = videoEnabled ? 'Video Activado' : 'Video Desactivado';
      // On some mobile browsers, need to re-acquire stream to apply camera change
      await refreshStreamsAndTracks();
    });

    // Toggle audio
    toggleAudioBtn.addEventListener('click', async () => {
      audioEnabled = !audioEnabled;
      if (localStream1) {
        localStream1.getAudioTracks().forEach(track => track.enabled = audioEnabled);
      }
      toggleAudioBtn.classList.toggle('active', audioEnabled);
      toggleAudioBtn.textContent = audioEnabled ? 'Micrófono Activado' : 'Micrófono Desactivado';
      await refreshStreamsAndTracks();
    });

    // Camera/mic selection change
    cameraSelect.addEventListener('change', async () => {
      await refreshStreamsAndTracks();
    });
    micSelect.addEventListener('change', async () => {
      await refreshStreamsAndTracks();
    });

    // --- Fix: assignLocalStreams should always use current localStream1 ---
    function assignLocalStreams() {
      Object.entries(camsLocal).forEach(([key, cam]) => {
        cam.srcObject = key === '1' ? localStream2 : localStream1;
        cam.play().catch(() => {});
      });
    }

    // --- Fix: getStreams should not set enabled state, let refreshStreamsAndTracks handle it ---
    async function getStreams() {
      try {
        const videoDeviceId = cameraSelect.value;
        const audioDeviceId = micSelect.value;
        localStream1 = await navigator.mediaDevices.getUserMedia({
          video: videoDeviceId ? { deviceId: { exact: videoDeviceId } } : true,
          audio: audioDeviceId ? { deviceId: { exact: audioDeviceId } } : true,
        });
        // Get second camera if available
        const videoDevices = (await navigator.mediaDevices.enumerateDevices()).filter(d => d.kind === 'videoinput');
        const secondCamId = videoDevices.find(d => d.deviceId !== videoDeviceId)?.deviceId;
        localStream2 = secondCamId
          ? await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: secondCamId } }, audio: false })
          : localStream1.clone();
        previewVideo.srcObject = localStream1;
        previewVideo.play().catch(() => {});
      } catch (error) {
        alert('No se pudo acceder a la cámara o micrófono. Permisos denegados o no disponibles.');
      }
    }
  </script>
</body>
</html>